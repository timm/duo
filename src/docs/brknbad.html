<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <title>brknbad.py</title>
  <link rel="stylesheet" href="pycco.css">
</head>
<body>
<div id='container'>
  <div id="background"></div>
  <div class='section'>
    <div class='docs'><h1>brknbad.py</h1></div>
  </div>
  <div class='clearall'>
  <div class='section' id='section-0'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-0'>#</a>
      </div>
      <p>Optimizer, written as a data miner.  Break the data up into regions
of &lsquo;bad&rsquo; and &lsquo;better&rsquo;. Find ways to jump from &lsquo;bad&rsquo; to &lsquo;better&rsquo;. 
Nearly all this processing takes loglinear time.</p>
<pre><code>:-------:  
| Ba    | Bad &lt;----.  planning= (better - bad)
|    56 |          |  monitor = (bad - better)
:-------:------:   |  
        | B    |   v  
        |    5 | Better  
        :------:
</code></pre>
<p>Copyright (c) 2020, Tim Menzies. All rights (BSD 2-Clause license).</p>
<h2>Overview</h2>
<p>Is your software ethical?  Does its own source code  holds a
representation of user goals and  uses those at runtime to guide
its own behavior?  Can that software report how well the user goals
are being achieved and can it suggest how to adjust the system, to
better achieve those goals?</p>
<p>Do you want to make your software more ethical?  BRKNBAD is a
collection of data structures that support ethical the kind of
ethical reasoning listed above.  It is a multi-objective optimizer
that reasons by breaking up problems into regions of <code>bad</code> and
<code>better</code>, then looks for ways on how to jump between those regions.</p>
<p>BRKNBAD might be an ethical choice in domains:</p>
<ul>
<li>when users have to trade-off competing goals, </li>
<li>when succinct explanations are needed about what the system is doing,</li>
<li>when  those explanations have to include ranges within which it is safe
  to change the system, </li>
<li>when guidance is needed for how to improve things
  (or know what might make things worse); </li>
<li>when thing being studied is constantly changing so:</li>
<li>we have to perpetually check if the current system is still trustworthy</li>
<li>and, if not, we need to update our models</li>
</ul>
<p>Technical notes: </p>
<ul>
<li><code>bad</code> and <code>better</code> are score via 
  <a href="#brknbad.Tab.dom">Zitler&rsquo;s continuous domination predicate</a>.</li>
<li>Examples are clustered in goal
  space and the <code>better</code> cluster is the one that dominates all the
  other <code>bad</code> clusters.</li>
<li>Numerics are then broken up into just a few ranges
  using a bottom-up merging process
  guided by the ratio of <code>better</code> to <code>bad</code>  in each range. </li>
<li>These numeric ranges,
  and the symbolic ranges are then used to build a succinct decision list
  that can explain what constitutes <code>better</code> behavior. 
  This decision list has many uses:<ul>
<li><em>Planning</em>: The deltas in the conditions that lead to the leaves of that decision list can
  offer guidance on how to change
  <code>bad</code> to <code>better</code>. </li>
<li><em>Monitoring</em>: The opposite of planning. Learn what can change <code>better</code>
  to <code>bad</code>, then watch out for those things.</li>
<li><em>Anomaly detection and incremental certification:</em> 
 The current decision list can be trusted as long as new examples 
 fall close to the old examples seen in the leaves of the decision list.</li>
<li><em>Stream mining</em>: Stop learning while the anomaly detector is not
  triggering. Track the anomalies seen each branch of the decision list.
  Update just the branches that get too many anomalies (if that ever happens).</li>
</ul>
</li>
</ul>
<h2>Classes</h2>
<p>In BNB, everything is a <code>Tab</code>le. When data is read from disk
it is entered into a <code>Tab</code>le. When collecting data from some
process, that data is incrementally written into a <code>Tab</code>le.
If we recursively cluster data, each level of that recursion
is a table.</p>
<p>into tables. that have <code>rows</code> and <code>cols</code>.
Each row is some example of <code>y=f(x)</code> where <code>y</code> and <code>x</code>
can have multiple values (and when <code>|y|&gt;1</code>, then this
then becomes a multi-objective reasoner).</p>
<p>Our  <code>rows</code> are just plain old Python lists. We can
compute the <code>dist</code>ance between rows as well as checking
if the goals in one row are &ldquo;better than&rdquo; (also known as
&ldquo;dominates&rdquo;) the other.</p>
<p><code>Col</code> objects summarize what was seen in each column. There are
two general kinds of <code>Col</code>s (<code>Num</code>erics and <code>Sym</code>bols) and
which can be categoriesed into</p>
<ul>
<li><code>y</code> values:</li>
<li>numeric goals (that we might want to maximize or minimze)</li>
<li>symbolic gaols (that are also called <code>klass</code>es)</li>
<li><code>x</code> values:</li>
<li>which can be numeric or symbolic.</li>
</ul>
<h2>License</h2>
<p>Copyright (c) 2020, Tim Menzies
All rights reserved.</p>
<p>Redistribution and use in source and binary forms, with or
without modification, are permitted provided that the
following conditions are met:</p>
<ol>
<li>
<p>Redistributions of source code must retain the above
   copyright notice, this
   list of conditions and the following disclaimer.</p>
</li>
<li>
<p>Redistributions in binary form must reproduce the above
   copyright notice,
   this list of conditions and the following disclaimer in
   the documentation and/or other materials provided with
   the distribution.</p>
</li>
</ol>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
CONTRIBUTORS &ldquo;AS IS&rdquo; AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre><span></span><span class="n">SOFTWARE</span><span class="p">,</span> <span class="n">EVEN</span> <span class="n">IF</span> <span class="n">ADVISED</span> <span class="n">OF</span> <span class="n">THE</span> <span class="n">POSSIBILITY</span> <span class="n">OF</span> <span class="n">SUCH</span> <span class="n">DAMAGE</span><span class="o">.</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">import traceback,argparse,random,pprint,math,sys,re,os</span>
<span class="s2">#DIVIDER</span>
<span class="s2">def help(): </span>
<span class="s2">  &quot;&quot;&quot;</span>
  <span class="n">Define</span> <span class="n">options</span><span class="o">.</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-1'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-1'>#</a>
      </div>
      <p>h = makeArgParseOption
return [
  h(&ldquo;verbose mode for Tree&rdquo;,                          treeVerbose= False),
  h(&ldquo;bin min size =len<strong>b&rdquo;,                           b= .5),
  h(&ldquo;what columns to while tree building &rdquo; ,          c= [&ldquo;x&rdquo;,&rdquo;y&rdquo;]),
  h(&ldquo;use at most &lsquo;d&rsquo; rows for distance calcs&rdquo;,        d= 256),
  h(&ldquo;separation of poles (f=1 means &lsquo;max distance&rsquo;)&rdquo;, f= .9),
  h(&ldquo;coefficient for distance&rdquo; ,                      p= 2),
  h(&ldquo;tree leaves must be at least n</strong>s in size&rdquo; ,     s= 0.5),
  h(&ldquo;training data (arff format&rdquo;,                     train= &ldquo;train.csv&rdquo;),
  h(&ldquo;testing data (csv format)&rdquo;,                      test=  &ldquo;test.csv&rdquo;),
  h(&ldquo;List all tests.&rdquo;,                                L = False),
  h(&ldquo;Run all tests.&rdquo;,                                 T = False),
  h(&ldquo;Run just the tests with names matching &lsquo;S&rsquo;&ldquo;,     t= &ldquo;&rdquo;)
]</p>
<p>def makeArgParseOption(txt,**d):</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>  <span class="n">Support</span> <span class="n">code</span> <span class="k">for</span> <span class="n">Command</span><span class="o">-</span><span class="n">line</span> <span class="n">Options</span><span class="o">.</span> <span class="n">Argument</span>
  <span class="n">types</span> <span class="n">are</span> <span class="n">inferred</span> <span class="n">by</span> <span class="n">peeking</span> <span class="n">at</span> <span class="n">the</span> <span class="n">default</span><span class="o">.</span>
  <span class="n">Different</span> <span class="n">types</span> <span class="n">then</span> <span class="n">lead</span> <span class="n">to</span> <span class="n">different</span> <span class="n">kinds</span> <span class="n">of</span> <span class="n">options</span><span class="o">.</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-2'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-2'>#</a>
      </div>
      <p>for k in d:
  key = k
  val = d[k]
  break
default = val[0] if isinstance(val,list)  else val
if val is False :
  return key,default,dict(help=txt, action=&rdquo;store_true&rdquo;)
else:
  m,t = &ldquo;S&rdquo;,str
  if isinstance(default,int)  : m,t= &ldquo;I&rdquo;,int
  if isinstance(default,float): m,t= &ldquo;F&rdquo;,float
  if isinstance(val,list):
    return key,default,dict(help=txt, choices=val,        <br />
                    default=default, metavar=m ,type=t)
  else:
    eg = &ldquo;; e.g. -%s %s&rdquo;%(key,val) if val != &ldquo;&rdquo; else &ldquo;&rdquo;
    return key,default, dict(help=txt + eg,
                    default=default, metavar=m, type=t)</p>
<p>def args(f):</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>  <span class="n">Link</span> <span class="n">to</span> <span class="n">Python</span><span class="s1">&#39;s command line option processor.</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-3'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-3'>#</a>
      </div>
      <p>lst = f()
before = re.sub(r&rdquo;\n  &ldquo;,&rdquo;\n&rdquo;, <strong>doc</strong>)
before = before.split(&lsquo;\n\n&rsquo;)[0]
parser = argparse.ArgumentParser(description = before,
           formatter_class = argparse.RawDescriptionHelpFormatter)
for key, _,args in lst:
  parser.add_argument(&ldquo;-&ldquo;+key,**args)
return parser.parse_args()</p>
<h1>---------------------------------------------------------</h1>
<p>class Magic:</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>  <span class="n">Define</span> <span class="n">magic</span> <span class="n">characterss</span><span class="o">.</span> 
  <span class="n">Used</span> <span class="ow">in</span> <span class="n">column</span> <span class="n">headers</span> <span class="n">to</span> <span class="n">denote</span> <span class="n">goals</span><span class="p">,</span> <span class="n">klasses</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span>
  <span class="n">Used</span> <span class="n">also</span> <span class="n">to</span> <span class="n">denote</span> <span class="n">things</span> <span class="n">to</span> <span class="n">skip</span> <span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="n">specific</span> <span class="n">cells</span><span class="p">)</span><span class="o">.</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-4'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-4'>#</a>
      </div>
      <p>def no(s): 
  &ldquo;Things to skip.&rdquo;
  return  s == &ldquo;?&rdquo;
def nump(s): 
  &ldquo;Numbers.&rdquo;
  return &ldquo;&lt;&rdquo; in s or &ldquo;$&rdquo; in s or &ldquo;&gt;&rdquo; in s
def goalp(s): 
  &ldquo;Goals&rdquo;
  return &ldquo;&lt;&rdquo; in s or &ldquo;!&rdquo; in s or &ldquo;&gt;&rdquo; in s
def klassp(s): 
  &ldquo;Non-numeric goals.&rdquo;
  return &ldquo;!&rdquo; in s
def lessp(s): 
  &ldquo;Thing to minimize&rdquo;
  return &ldquo;&lt;&rdquo; in s</p>
<h1>---------------------------------------------------------</h1>
<h3>Thing</h3>
<h1>Python objects have <em>very</em> uninformative print strings.</h1>
<h1><code>Thing</code>s know how to present themselves.</h1>
<p>class Thing:</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>  <span class="n">All</span> <span class="n">my</span> <span class="n">classes</span> <span class="n">are</span> <span class="n">Things</span> <span class="n">that</span> <span class="n">pretty</span> <span class="nb">print</span> <span class="n">themselves</span>
  <span class="n">by</span> <span class="n">reporting</span> <span class="n">themselves</span> <span class="k">as</span> <span class="n">nested</span> <span class="n">dictionaries</span> <span class="n">then</span> 
  <span class="n">pprint</span><span class="o">-</span><span class="n">ing</span> <span class="n">that</span> <span class="n">dictionary</span><span class="o">.</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-5'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-5'>#</a>
      </div>
      <p>def <strong>repr</strong>(i):
   return re.sub(r&rdquo;&rsquo;&ldquo;,&rsquo; &lsquo;, 
                 pprint.pformat(dicts(i.<strong>dict</strong>),compact=True))</p>
<p>def dicts(i,seen=None):</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>  <span class="n">This</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">tool</span> <span class="n">used</span> <span class="n">by</span> <span class="err">`</span><span class="n">Thing</span><span class="err">`</span><span class="o">.</span>
  <span class="n">Converts</span> <span class="err">`</span><span class="n">i</span><span class="err">`</span> <span class="n">into</span> <span class="n">a</span> <span class="n">nested</span> <span class="n">dictionary</span><span class="p">,</span> <span class="n">then</span> <span class="n">pretty</span><span class="o">-</span><span class="n">prints</span> <span class="n">that</span><span class="o">.</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-6'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-6'>#</a>
      </div>
      <p>if isinstance(i,(tuple,list)): 
  return [ dicts(v,seen) for v in i ]
elif isinstance(i,dict): 
  return { k:dicts(i[k], seen) for k in i if str(k)[0] !=&rdquo;_&rdquo;}
elif isinstance(i,Thing): 
  seen = seen or {}
  j =id(i) % 128021 # ids are LONG; show them shorter.
  if i in seen: return f&rdquo;#:{j}&rdquo;
  seen[i]=i
  d=dicts(i.<strong>dict</strong>,seen)
  d[&ldquo;#&rdquo;] = j
  return d
else:
  return i</p>
<p>class o(Thing):
def <strong>init</strong>(i,<strong>d) : i.<strong>dict</strong>.update(</strong>d)</p>
<p>my  = o(**{k:d for k,d,_ in help()})</p>
<p>class Col(Thing):
def <strong>init</strong>(i,pos,txt):
  i.n, i.pos, i.txt = 0, pos, txt
  i.w = -1 if Magic.lessp(txt) else 1
def <strong>add</strong>(i,x):
  if Magic.no(x): return x
  i.n += 1
  return i.add(x)</p>
<p>class Num(Col):
def <strong>init</strong>(i, <em>l):
  super().<strong>init</strong>(</em>l)
  i.mu, i.lo, i.hi = 0, 10<strong>32, -10</strong>32
def mid(i): return i.mu
def add(i,x):
  x = float(x)
  i.lo,i.hi = min(i.lo,x), max(i.hi,x)
  i.mu      = i.mu + (x - i.mu)/i.n
  return x
def norm(i,x):
  if Magic.no(x) : return x
  return (x - i.lo)  / (i.hi - i.lo + 0.000001)
def dist(i,x,y):
  if Magic.no(x) and Magic.no(y): return 1
  if Magic.no(x): x = i.lo if y &gt; i.mu else i.hi
  if Magic.no(y): y = i.lo if x &gt; i.mu else i.hi
  return abs(i.norm(x) - i.norm(y))</p>
<p>class Sym(Col):
def <strong>init</strong>(i, <em>l):
  super().<strong>init</strong>(</em>l)
  i.seen, i.most, i.mode = {}, 0, None
def mid(i): return i.mode
def add(i,x):
  tmp = i.seen[x] = i.seen.get(x,0) + 1
  if tmp &gt; i.most: i.most,i.mode = tmp,x
  return x
def dist(i,x,y): 
  return 1 if Magic.no(x) and Magic.no(y) else x != y</p>
<p>class Cols(Thing):
def <strong>init</strong>(i) : 
  i.x,i.y,i.nums,i.syms,i.all,i.klas = {},{},{},{},[],None
def add(i,lst): 
  [ col.add( lst[col.pos] ) for col in i.all ]
def klass(i,lst): 
  return lst[i.klas]
def header(i,lst):
  for pos,txt in enumerate(lst):
    tmp = (Num if Magic.nump(txt) else Sym)(pos,txt)
    i.all += [tmp]
    (i.y    if Magic.goalp(txt) else i.x)[pos] = tmp
    (i.nums if Magic.nump(txt)  else i.syms)[pos] = tmp
    if Magic.klassp(txt) : i.klas  = tmp</p>
<p>class Tab(Thing):
def <strong>init</strong>(i,rows=[]):
  i.rows, i.cols = [], Cols()
  [i.add(row) for row in rows]
def clone(i,rows=[]):
  t  = Tab()
  t  + [c.txt for c in i.cols.all] 
  [t + row for row in  rows]
  return t
def <strong>add</strong>(i,a): 
  return i.add(a) if i.cols.all else i.cols.header(a)
def add(i,a): 
  i.rows +=  <a href="c + a[c.pos] for c in i.cols.html">c + a[c.pos] for c in i.cols.all</a>
def read(i,data=None): 
  [i + row for row in cols(rows(data))]
  return i
def pairs(i,col):
  return Bins(col.pos,i.rows, lambda z: z[col.pos], 
                              lambda z: i.cols.klass(z))
def status(i):
  return &lsquo;{&lsquo; + &lsquo;, &lsquo;.join([(&lsquo;%.2f&rsquo; % c.mid()) 
                   for c in i.cols.y.values()]) + &lsquo;}&rsquo;
def mid(i):
  return [ col.mid() for col in i.cols.all ]
def dom(i,row1,row2):
  s1,s2,n = 0,0,len(i.cols.y)+0.0001
  for c in i.cols.y.values():
    x   = c.norm( row1[c.pos] )
    y   = c.norm( row2[c.pos] )
    s1 -= math.e<strong>(c.w*(x-y)/n)
    s2 -= math.e</strong>(c.w*(y-x)/n)
  return s1/n &lt; s2/n</p>
<p>class Dist:
def <strong>init</strong>(i, t,cols=None, rows=None, p=my.p):
  i.t= t
  i.p= p
  i.cols = cols or t.cols.x
  i.rows = rows or shuffle(t.rows)[:my.d]
def dist(i,row1,row2):
  d = 0
  for col in i.cols.values():
    inc = col.dist( row1[col.pos], row2[col.pos] )
    d  += inc<strong>my.p
  return (d/len(i.cols))</strong>(1/my.p)
def neighbors(i,r1):
  a = [(i.dist(r1,r2),r2) for r2 in i.rows if id(r1) != id(r2)]
  return sorted(a, key = lambda z: z[0])
def faraway(i,row):
   a= i.neighbors(row)
   return a[ int( len(a) * my.f ) ][1]
def poles(i):
   tmp   = random.choice(i.rows)
   left  = i.faraway(tmp)
   right = i.faraway(left)
   return left, right, i.dist(left,right)
def project(i,row, left,right,c):
   a = i.dist(row,left)
   b = i.dist(row,right)
   d = (a<strong>2 + c</strong>2 - b*<em>2) / (2</em>c)
   if d&gt;1: d= 1
   if d&lt;0: d= 0
   return d</p>
<p>class Tree:
 def <strong>init</strong>(i, t, cols=my.c, lo=None, lvl=0):
   lo = lo or 2<em>len(t.rows)</em><em>my.s
   if len(t.rows) &gt; lo:
     if my.treeVerbose:
       print((&lsquo;| &lsquo;</em>lvl) + str(len(t.rows)))
     i.d         = Dist(t,cols=t.cols.<strong>dict</strong>[cols])
     i.l,i.r,i.c = i.d.poles()
     xs          = [i.d.project(r,i.l,i.r,i.c) for r in t.rows]
     i.mid       = sum(xs) / len(xs)
     i.kids      = [t.clone(),t.clone()]
     [i.kids[x &gt;= i.mid].add(r)     for x,r in zip(xs, t.rows)]
     if len(i.kids[0].rows) &lt; len(t.rows) and \
        len(i.kids[1].rows) &lt; len(t.rows) :
        [ Tree(kid, cols=cols, lo=lo, lvl=lvl+1) 
          for kid in i.kids ]
   else:
     if my.treeVerbose:
       print((&lsquo;| &lsquo;*lvl) + str(len(t.rows)),t.status())</p>
<p>class Bore:
 def <strong>init</strong>(i, t) :
   i.rest = t.clone()
   i.best = i.div(t, 2<em>len(t.rows)</em>*my.s)
 def div(i,t,lo):
   if len(t.rows) &lt; lo: return  t
   d     = Dist(t,cols=t.cols.y)
   l,r,c = d.poles()
   xs    = [d.project(row,l,r,c) for row in t.rows]
   mid   = sum(xs) / len(xs)
   kid   = t.clone()
   if t.dom(l, r):
     for x,row in zip(xs, t.rows):
       (kid if x &lt; mid else i.rest).add(row)
   else:
     for x,row in zip(xs, t.rows):
       (kid if x &gt;=  mid else i.rest).add(row)
   return i.div(kid,lo)</p>
<p>class SRanges(Thing): 
def <strong>init</strong>(i, txt, a, x, y, goal=True):
  i.txt  = txt
  i.goal = goal
  i.all  = Range(txt,x,i),
  d      = {}
  for one in a:
    x1, y1 = x(one), y(one)
    if Magic.no(x1): continue
    if not x1 in d: d[x1] = Range(txt,x,i)
    d[x].add(x1,y1)
    i.all.add(x1,y1)
  i.ranges =  d.values()</p>
<p>class Range:
def <strong>init</strong>(i,what,xf,ranges):
  i.what,i.xf,i.ranges = what, xf, ranges
  i.n, i.yes, i.no = 0,0.0001,0.0001
  i.lo, i.hi = None,None
def add(i,x,y):
  i.n += 1
  if y==i.ranges.goal: i.yes += 1
  else               : i.no += 1
  i.lo = min(x,i.lo)
  i.hi = max(x,i.hi)
def merge(i,j):
  k     = i.ranges.bin()
  k.lo  = min(i.lo, j.lo) 
  k.hi  = max(i.hi, j.hi) 
  k.n   = i.n + j.n
  k.no  = i.no  + j.no
  k.yes = i.yes + j.yes
  return k
def better(c,a,b):
  sa, sb, sc = a.s(), b.s(), c.s()
  return abs(sb - sa) &lt; my.e or sc &gt;= sb and sc &gt;= sa
def s(i):
  yes   = i.yes/i.ranges.all.yes 
  no    = i.no /i.ranges.all.no
  return  yes**2/(yes+no+0.0001) if yes &gt; no else 0</p>
<p>class Ranges(Thing):
def <strong>init</strong>(i,txt,a,x=lambda z:z[0],
                     y=lambda z:z[1], goal=True):
  i.txt  = txt
  i.goal = goal
  i.bin  = lambda: Range(txt,x,i)
  i.all  = i.bin()
  i.ranges= i.merge( i.grow( i.pairs(x,y,a)))
def pairs(i,x,y,a):
  lst = [(x(z), y(z)) for z in a if not isinstance(x(z),str)]
  return sorted(lst, key= lambda z:z[0])
def grow(i,a):
  min  = len(a)**my.b
  use  = len(a) - min
  bins = [i.bin()]
  for j,(x,y) in enumerate(a):
    if j &lt; use and bins[-1].n &gt; min:
      bins += [i.bin()]
    bins[-1].add(x,y)
    i.all.add(x,y) 
  return bins
def merge(i,bins):
  j, tmp = 0, []
  while j &lt; len(bins):
     a = bins[j]
     if j &lt; len(bins) - 1:
        b = bins[j+1]
        c = a.merge(b)
        if c.better(a,b,i.all):
           a = c
           j += 1
     tmp += [a]
     j += 1
  return i.merge(tmp) if len(tmp) &lt; len(bins) else bins</p>
<h1>--------------------------------------------------------</h1>
<h1>Utils</h1>
<p>def rows(x=None):
&ldquo;Read a csv file from disk.&rdquo;
prep=lambda z: re.sub(r&rsquo;([\n\t\r ]|#.*)&rsquo;,&rsquo;&lsquo;,z.strip())
if x:
  with open(x) as f:
    for y in f: 
       z = prep(y)
       if z: yield z.split(&ldquo;,&rdquo;)
else:
 for y in sys.stdin: 
       z = prep(y)
       if z: yield z.split(&ldquo;,&rdquo;)</p>
<p>def cols(src):
&ldquo;Ignore columns if, on line one, the name contains &lsquo;?&rsquo;.&rdquo;
todo = None
for a in src:
  todo = todo or [n for n,s in enumerate(a) if not &ldquo;?&rdquo;in s]
  yield [ a[n] for n in todo]</p>
<p>def shuffle(lst):
&ldquo;Return a shuffled list.&rdquo;
random.shuffle(lst)
return lst</p>
<p>def has(i,seen=None):</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>  <span class="n">Report</span> <span class="n">a</span> <span class="n">nested</span> <span class="nb">object</span> <span class="k">as</span> <span class="n">a</span> <span class="nb">set</span> <span class="n">of</span> <span class="n">nested</span> <span class="n">lists</span><span class="o">.</span>
  <span class="n">If</span> <span class="n">we</span> <span class="n">see</span> <span class="n">the</span> <span class="n">same</span> <span class="err">`</span><span class="n">Thing</span><span class="err">`</span> <span class="n">twice</span><span class="p">,</span> <span class="n">then</span> <span class="n">show</span> <span class="n">it</span> <span class="n">the</span> 
  <span class="n">first</span> <span class="n">time</span><span class="p">,</span> <span class="n">after</span> <span class="n">which</span><span class="p">,</span> <span class="n">just</span> <span class="n">show</span> <span class="n">its</span> <span class="nb">id</span><span class="o">.</span> <span class="n">Do</span> <span class="ow">not</span> 
  <span class="k">return</span> <span class="n">anything</span> <span class="n">that</span> <span class="ow">is</span> <span class="n">private</span><span class="p">;</span>
  <span class="n">i</span><span class="o">.</span><span class="n">e</span><span class="o">.</span> <span class="n">anything</span> <span class="n">whose</span> <span class="n">name</span> <span class="n">starts</span> <span class="k">with</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-7'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-7'>#</a>
      </div>
      <p>seen = seen or {}
if isinstance(i,Thing): 
   j =id(i) % 128021
   if i in seen: return f&rdquo;#:{j}&rdquo;
   seen[i]=i
   d=has(i.<strong>dict</strong>,seen)
   d[&ldquo;#&rdquo;] = j
   return d
if isinstance(i,(tuple,list)): 
   return [ has(v,seen) for v in i ]
if isinstance(i,dict): 
   return { k:has(i[k], seen) for k in i if str(k)[0] !=&rdquo;_&rdquo;}
return i</p>
<p>def dprint(d, pre=&rdquo;&ldquo;,skip=&rdquo;_&rdquo;):</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>  <span class="n">Pretty</span> <span class="nb">print</span> <span class="n">a</span> <span class="n">dictionary</span><span class="p">,</span> <span class="nb">sorted</span> <span class="n">by</span> <span class="n">keys</span><span class="p">,</span> <span class="n">ignoring</span> 
  <span class="n">private</span> <span class="n">slots</span> <span class="p">(</span><span class="n">those</span> <span class="n">that</span> <span class="n">start</span> <span class="k">with</span> <span class="s1">&#39;_&#39;</span><span class="n">_</span><span class="p">)</span><span class="o">.</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-8'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-8'>#</a>
      </div>
      <p>def q(z):
  if isinstance(z,float): return &ldquo;%5.3f&rdquo; % z
  if callable(z): return &ldquo;f(%s)&rdquo; % z.<strong>name</strong>
  return str(z)
l = sorted([(k,d[k]) for k in d if k[0] != skip])
return pre+&rsquo;{&lsquo;+&rdquo;, &ldquo;.join([(&lsquo;%s=%s&rsquo; % (k,q(v))) 
                           for k,v in l]) +&rsquo;}&rsquo;</p>
<p>class Test:</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>  <span class="n">Unit</span> <span class="n">test</span> <span class="n">manager</span><span class="o">.</span> <span class="n">Stores</span> <span class="nb">all</span> <span class="n">the</span> <span class="n">tests</span> <span class="ow">in</span> <span class="err">`</span><span class="n">Test</span><span class="o">.</span><span class="n">all</span><span class="err">`</span><span class="o">.</span> 
  <span class="n">Lets</span> <span class="n">you</span> <span class="nb">list</span> <span class="n">the</span> <span class="n">tests</span><span class="p">,</span> <span class="n">run</span> <span class="n">some</span> <span class="n">of</span> <span class="n">them</span><span class="p">,</span> <span class="ow">or</span> <span class="nb">all</span><span class="o">.</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-9'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-9'>#</a>
      </div>
      <p>t,f = 0,0
all = []
def score(s): 
  t,f = Test.t, Test.f
  return f&rdquo;#TEST {s} passes = {t-f} fails = {f}&rdquo;
def go(fn=None, use=None):
  if fn:
    Test.all += [fn]
  elif use:
    [Test.run(fn) for fn in Test.all if use in fn.<strong>name</strong>]
  else: 
    [Test.run(fn) for fn in Test.all]
def run(fun):  <br />
  try:
    Test.t += 1
    print(&ldquo;### &ldquo;,fun.<strong>name</strong>)
    doc = fun.<strong>doc</strong> or &ldquo;&rdquo;
    print( &ldquo;# &ldquo;+ re.sub(r&rdquo;\n[ ]<em>&rdquo;,&rdquo;\n# &ldquo;,doc) )
    print(&ldquo;&rdquo;)
    random.seed(1)
    fun()
    print(Test.score(&ldquo;PASS&rdquo;),&rsquo;:&rsquo;,fun.<strong>name</strong>)
  except Exception:
    Test.f += 1
    print(traceback.format_exc())
    print(Test.score(&ldquo;FAIL&rdquo;),&rsquo;:&rsquo;,fun.<strong>name</strong>)
def list():
  print(&ldquo;&rdquo;)
  print(<strong>file</strong> + &rdquo; -t [NAME]&rdquo;) 
  print(&ldquo;\nKnown test names:&rdquo;)
  for fun in Test.all:
    name = re.sub(r&rdquo;test_&rdquo;,&rdquo;&ldquo;,fun.<strong>name</strong>)
    doc = fun.<strong>doc</strong> or &ldquo;&rdquo;
    doc = re.sub(r&rdquo;\n[ ]</em>&rdquo;,&rdquo;&ldquo;,doc)
    print(f&rdquo;  {name:10s} : {doc}&rdquo;)</p>
<h1>----------------------------------------------</h1>
<h3>Unit Tests</h3>
<p>def go(fn=None,use=None):<br />
&ldquo;Decorator for test functions. Adds the function to <code>Test.all</code>&rdquo;
Test.go(fn=fn,use=use); return fn</p>
<p>@go
def test_tests():
&ldquo;List all tests.&rdquo;
Test.list()</p>
<p>@go
def test_bye():  <br />
&ldquo;Commit and push Github files.&rdquo;
def run(s): print(s); os.system(s)
run(&ldquo;git commit -am commit&rdquo;)
run(&ldquo;git push&rdquo;)
run(&ldquo;git status&rdquo;)</p>
<p>@go
def test_hello(): 
&ldquo;Simple test1.&rdquo;
print(about()[0])</p>
<p>@go
def test_hetab1():</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>  <span class="n">Read</span> <span class="n">a</span> <span class="n">small</span> <span class="n">table</span> <span class="kn">from</span> <span class="nn">disk.</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-10'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-10'>#</a>
      </div>
      <p>t = Tab().read(&ldquo;../docs/data/weather4.csv&rdquo;)
assert( 4 == t.cols.x[0].seen[&ldquo;overcast&rdquo;])
assert(14 == t.cols.x[0].n)
assert(14 == len(t.rows))
assert( 4 == len(t.cols.all))
assert( 3 == len(t.cols.syms))
print(t)</p>
<p>@go
def test_tab2():
&ldquo;Read a larger table from disk.&rdquo;
t = Tab().read(&ldquo;data/auto93.csv&rdquo;)
assert(398 == len(t.rows))</p>
<p>@go
def test_dist():
&ldquo;Check the distance calculations.&rdquo;
t = Tab().read(&ldquo;../docs/data/auto93.csv&rdquo;)
d = Dist(t)
for r1 in shuffle(t.rows)[:10]:
  if not &ldquo;?&rdquo; in r1:
     assert(d.dist(r1,r1) == 0)
  n = d.neighbors(r1)
  r2 = n[ 0][1]
  r3 = n[-1][1]
  r4 = d.faraway(r1)
  print(&ldquo;&rdquo;)
  print(r1)
  print(r2, f&rsquo;{d.dist(r1,r2):.3f}&rsquo;)
  print(r4, f&rsquo;{d.dist(r1,r4):.3f}&rsquo;)
  print(r3, f&rsquo;{d.dist(r1,r3):.3f}&rsquo;)
  print(*d.poles())</p>
<p>@go
def test_tree():
&ldquo;Recursively divide the data in two.&rdquo;
t = Tab().read(&ldquo;../docs/data/auto93.csv&rdquo;)
my.treeVerbose = True
Tree(t,cols=&rdquo;y&rdquo;)</p>
<p>@go
def test_bore():</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre>  <span class="n">Recursively</span> <span class="n">prune</span> <span class="n">worst</span> <span class="n">half</span> <span class="n">the</span> <span class="n">data</span> 
  <span class="p">(</span><span class="n">down</span> <span class="n">to</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="n">of</span> <span class="n">original</span> <span class="n">data</span><span class="p">)</span><span class="o">.</span>

</pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-11'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-11'>#</a>
      </div>
      <p>t = Tab().read(&ldquo;../docs/data/auto93.csv&rdquo;)
b = Bore(t)
print([col.txt for col in t.cols.y.values()])
print(&ldquo;best&rdquo;,b.best.status())
print(&ldquo;rest&rdquo;,b.rest.status())
print(&ldquo;all&rdquo;,t.status())</p>
<p>def _range0(xy):
print(&ldquo;&rdquo;)
for x in Ranges(&ldquo;t&rdquo;,xy).ranges(): 
  print(x)</p>
<p>@go
def test_range1():
n = 10
_range0([[i,i&gt;n] for i in range(n*2)])</p>
<h1>----------------------------------------------</h1>
<h3>Main</h3>
<h1>Start-up commands.</h1>
<p>if <strong>name</strong> == &ldquo;<strong>main</strong>&rdquo;:
my = args(help)
if my.T: go()
if my.t: go(use=my.t)
if my.L: Test.list()</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
</div>
</body>
