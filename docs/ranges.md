# Ranges
Supervised discretization of numerics, based on some discrete class
value.  This is a bottom-up procedure that first divides ranges
into (say) 16 bins, then repeatedly merge similar adjacent bins.

```py
from lib import Thing,o,dprint
from num import Num
from sym import Sym
import sys
```
## Classes
This code uses two classes:
- `Range` stores information about one range;
- `Ranges` is a manager class that:
  - Firstly,  builds the ranges;
  - Secondly, repeatedly  find, then combined, adjacent similar ranges.

### Range
This class stores what we know about a range.  It stores a count
of the number of `best` classes  n a range, as well as the `lo` and
`hi`  values seen in this range.

```py
class Range(Thing):
  def __init__(i, want, min):
    i.want  = want
    i.best  = i.rest = 0.00001
    i.min   = min
    i.lo    = sys.maxsize - 1
    i.hi    = -i.lo
    i.n     = 0
```
Score a range.
```py
  def score(i, bs, rs):
     b = i.best  / bs
     r = i.rest  / rs
     return b**2 / (b+r)
```
Update the internal counts of a range.
```py    
  def add(i,x,y):
    i.lo    = min(x, i.lo)
    i.hi    = max(x, i.hi)
    i.n    += 1
    i.best += (y == i.want)
    i.rest += (y != i.want)
    return i
```
Merge two ranges.
```py
  def merge(i,j):
     k      = Range(i.want, i.min)
     k.lo   = min(i.lo, j.lo)
     k.hi   = max(i.hi, j.hi)
     k.n    = i.n    + j.n
     k.best = i.best + j.best
     k.rest = i.rest + j.rest
     return k
```
### Ranges
This classes creates the `Range`s and, then, 
repeatedly combine similar things.

It works this way. Given a list of `[x,y]` pairs,

1. Sort on `x`; 
2. Then divide the `x` values into many small bins;
2. Then repeatedly,
   - find adjacent bins which, if combined, 
     do _no better_ than the combination;
   - Merge them;
   - And repeat, till no more merge-able items are found.

Here, _no better_ is defined by the `Range.score` method:

- Given a range containing `b` best things and `r` rest;
- And a total number of `B` and `R` things found in all ranges;
- Then the value of that range is 
  &alpha;<sup>2</sup>/(&alpha; + &beta;) 
  where &alpha; =`b/B` and &beta; =`r/R`
- This function rewards ranges that have many more examples
  of the best things than anything else.

```py
class Ranges:
  bins = [16,8,4,2]
  min  = 4
  def __init__(i, xy, goal = True,debug=False):
    xy.sort(key = lambda z:z[0])
    i.min  = i.whatSize(xy)
    i.bs, i.rs = 0.0001, 0.0001
    i.all = i.divide(goal, xy)
```
Work out how small a bin can be and still be larger
than some useful minimum.
```py
  def whatSize(i,a):
    lo = 0
    least = Ranges.min if len(a) < 256 else len(a)**0.5
    for j in Ranges.bins:
      lo = int( len(a)/j )
      if lo >= least:  
        return lo
    return max(least,lo)
```
Chop things up.
```py
  def divide(i, goal, xy):
    out = [ Range(goal, i.min) ]
    for j,(x,y) in enumerate(xy):
      i.bs += (y == goal)
      i.rs += (y != goal)
      out[-1].add(x,y)
      if out[-1].n >= i.min:    # good ranges have "min" items
        if j < len(xy) - i.min: # enough space for other ranges
          if x != xy[j+1][0]:
            out += [ Range(goal, i.min) ]
    return out
```
Run over the `i.all` list generated by the `Range.divide` function.
If you can merge two adjacent items:
- Merge them, then jump two places to something else:
  - i.e. jump by `j += 2`
- If you can't merge, then just go onto the next bin:
  - i.e. jump by `j += 1`

```py
  def merge(i,lvl=1):
    j, tmp, pre = 0, [], "|-- " * lvl
    while j < len(i.all):
      a = i.all[j]
      if j< len(i.all) - 1:
        b = i.all[j+1]
        c = a.merge(b)
        if i.v(c) >= i.v(a) and i.v(c) >= i.v(b):
          tmp  += [c]
          j    += 2
          continue
      tmp  += [a]
      j    += 1
    if len(tmp) < len(i.all): # we now have fewer bins
      i.all = tmp             # so update "all"
      i.merge(lvl+1) # repeat:  can merge anything else?
```
Support tricks.
```py
  def v(i,z): 
    return z.score(i.bs, i.rs)

  def ranges(i):
    i.merge() 
    for z in i.all: 
      yield z.lo, z.hi, i.v(z)
```
