<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>duo API documentation</title>
<meta name="description" content="DUO = data miners used / used-by optimizers.
(c) Tim Menzies, 2021 MIT License, https://opensource.org/licenses/MIT â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>duo</code></h1>
</header>
<section id="section-intro">
<p>DUO = data miners used / used-by optimizers.
(c) Tim Menzies, 2021 MIT License, <a href="https://opensource.org/licenses/MIT.">https://opensource.org/licenses/MIT.</a></p>
<p>Sort the data by how much each row dominates over rows.
Split the
sort into 'bad' and 'better'. Discretize data, combining any splits
that do not comment on those splits.
Count how often ranges appear
in 'bad' or 'better'.
Sort the ranges by how likely they appear
in better.
Build rules by combining different ranges; i.e.
pick
pairs of better ranges, combine them, then sort them back into the
list.</p>
<pre><code> :-------:                 explore  = better==bad
 | Ba    | Bad &lt;----.      planning = max(better - bad)
 |    56 |          |      monitor  = max(bad - better)
 :-------:------:   |      tabu     = min(bad + better)
         | B    |   v
         |    5 | Better
         :------:
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
DUO = data miners used / used-by optimizers.
(c) Tim Menzies, 2021 MIT License, https://opensource.org/licenses/MIT.

Sort the data by how much each row dominates over rows.  Split the
sort into &#39;bad&#39; and &#39;better&#39;. Discretize data, combining any splits
that do not comment on those splits.  Count how often ranges appear
in &#39;bad&#39; or &#39;better&#39;.  Sort the ranges by how likely they appear
in better.  Build rules by combining different ranges; i.e.  pick
pairs of better ranges, combine them, then sort them back into the
list.

     :-------:                 explore  = better==bad
     | Ba    | Bad &lt;----.      planning = max(better - bad)
     |    56 |          |      monitor  = max(bad - better)
     :-------:------:   |      tabu     = min(bad + better)
             | B    |   v
             |    5 | Better
             :------:
&#34;&#34;&#34;

import math
from lib import args, csv, sd, mu, symsp, numsp, isa, any, r, seed
from duolib import showRule, selects, cell
from tiny import o, of
from the import THE
from tbl import table

def classify(tbl):
  &#34;&#34;&#34;Count how often each row dominates some others.
     Classify a row as True if it scores in the top _best_ range.&#34;&#34;&#34;
  def norm(lst, x): return (
      x - lst[0]) / (lst[-1] - lst[0] + 1E-32)

  def better(tbl, row1, row2):
    &#34;Zitler&#39;s continous domination predicate (from IBEA, 2005).&#34;
    s1, s2, n = 0, 0, len(tbl.y)
    for col in tbl.y.values():
      pos, w = col.pos, col.w
      a, b = row1.cells[pos], row2.cells[pos]
      a, b = norm(col.has, a), norm(col.has, b)
      s1 -= math.e**(w * (a - b) / n)
      s2 -= math.e**(w * (b - a) / n)
    return s1 / n &lt; s2 / n
  #######################
  for row1 in tbl.rows:
    row1.score = sum(better(tbl, row1, any(tbl.rows))
                     for _ in range(THE.rowsamples)) / THE.rowsamples
  for n, row in enumerate(sorted(tbl.rows, key=lambda z: z.score)):
    row.klass = n &gt; len(tbl.rows) * THE.best
  return tbl


#######################################################
def discretize(TBL):
  &#34;&#34;&#34;Reports `bins` for each numeric columns. Initially,
  columns of `N` (x,y) values  into bins of size N^Xchop.
  Combines bins that are smaller than `sd(x)*xsmall`. Then combine
  bins that are different by less than `sd(y)*ysmall`. Also, if
  two adjacent bins are not not &#39;best&#39;, then they are dull and
  we fuse them.  For example, from ../data/auto93.csv, we
  get  learn that &#39;-cylinders&#39; effectively divides into 3:

    [{&#39;hi&#39;: 4, &#39;lo&#39;: -inf},
     {&#39;hi&#39;: 8, &#39;lo&#39;: 5},
     {&#39;hi&#39;: inf, &#39;lo&#39;: 5}]

  Note that the above used &#39;best=.5&#39; i.e. we were were dividing data
  half:half into best:rest. But we ran the same code with &#39;best=.8&#39; then
  we find a different picture of what is interesting or not:

    [{&#39;hi&#39;: 4, &#39;lo&#39;: -inf},
     {&#39;hi&#39;: inf, &#39;lo&#39;: 3}]

  That is, at &#39;best=.8&#39; all we care about is whether or not &#39;cylinders&#39;
  is above or below 3.;

  &#34;&#34;&#34;

  def Span(lo=-math.inf, hi=math.inf, has=None):
    return o(lo=lo, hi=hi, _has=has if has else [])

  def pairs(lst, fx, fy):
    xs, ys, xy = [], [], []
    for one in lst:
      x = fx(one)
      if x != &#34;?&#34;:
        y = fy(one)
        xs += [x]
        ys += [y]
        xy += [(x, y)]
    ys = sorted(ys)
    return (sd(sorted(xs)) * THE.xsmall,
            sd(ys) * THE.ysmall,
            ys[int(THE.best * len(ys))],
            sorted(xy))

  def div(xsmall, ysmall, ymin, xy):
    n = len(xy)**THE.Xchop
    while n &lt; 4 and n &lt; len(xy) / 2:
      n *= 1.2
    n, tmp, b4, span = int(n), [], 0, Span(lo=xy[0][0])
    now = n
    while now &lt; len(xy) - n:
      x = xy[now][0]
      span.hi = x
      now += 1
      if (now - b4 &gt; n and now &lt; len(xy) - 2
          and x != xy[now][0]
              and span.hi - span.lo &gt; xsmall):
        span._has = [z[1] for z in xy[b4:now]]
        tmp += [span]
        span = Span(lo=xy[now][0])
        b4 = now
        now += n
    tmp += [Span(lo=xy[b4][0], hi=xy[-1][0],
                 has=[z[1] for z in xy[b4:]])]
    out = merge(tmp, ymin, ysmall)
    out[0].lo = -math.inf
    out[-1].hi = math.inf
    return out

  def merge(b4, ymin, ysmall):
    j, now = 0, []
    while j &lt; len(b4):
      a = b4[j]
      if j &lt; len(b4) - 1:
        b = b4[j + 1]
        if (abs(mu(b._has) - mu(a._has)) &lt; ysmall
            or
                (mu(b._has) &lt; ymin and mu(a._has) &lt; ymin)):
          merged = Span(lo=a.lo, hi=b.hi, has=a._has + b._has)
          now += [merged]
          j += 2
      now += [a]
      j += 1
    return merge(now, ymin, ysmall) if len(now) &lt; len(b4) else now

  for col in TBL.x.values():
    if numsp(col.has):
      col.spans = div(*pairs(TBL.rows,
                             lambda z: z.cells[col.pos],
                             lambda z: z.score))
      print(f&#34;NUM {col.txt:12} :&#34;, [x.hi for x in col.spans])
    else:
      print(f&#34;SYM {col.txt:12} :&#34;, sorted(col.has.keys()))
  return TBL


def counts(TBL):
  &#34;&#34;&#34;Counts (class column attribute) inside `TBL`
   (where attributes are the discretized attributes).
   THe counts take the form: (cKass,attribute,range,col), count.
   For example, with best=.9, the counts from ../data/auto93.csv
   are as follows. Note the simplicity of the decision space:
   all that matters is displacement and horsepower is above below
   141 and 74

      (False, &#39;displacement&#39;, 141, 1) 154
      (False, &#39;displacement&#39;, inf, 1) 205
      (False, &#39;horsepower&#39;, 74, 2) 48
      (False, &#39;horsepower&#39;, inf, 2) 307
      ....
      (True, &#39;displacement&#39;, 141, 1) 38
      (True, &#39;displacement&#39;, inf, 1) 1
      (True, &#39;horsepower&#39;, 74, 2) 34
      (True, &#39;horsepower&#39;, inf, 2) 3
      ....

   &#34;&#34;&#34;

  def Counts(): return o(f={}, h={}, n=0)
  out = Counts()
  for row in TBL.rows:
    k = row.klass
    out.n += 1
    out.h[k] = out.h.get(k, 0) + 1
    for col in TBL.x.values():
      x = cell(col, row)
      if x:
        v = (k, col.txt, x)
        out.f[v] = out.f.get(v, 0) + 1
  return out


#######################################################
def learn(COUNTS):
  def loop(rules, here, there):
    lives = THE.lives
    while True:
      lives -= 1
      total, rules = prune(rules)
      if lives &lt; 1 or len(rules) &lt; 2:
        return rules
      rules += [combine(pick(rules, total),
                        pick(rules, total),
                        here, there)]

  def value(rule, here, there, e=2):
    b = like(rule, here, 2)
    r = like(rule, there, 2)
    return b**e / (b + r) if b &gt; r else 0

  def like(rule, h, hs=None):
    hs = hs if hs else len(COUNTS.h)
    like = prior = (COUNTS.h[h] + THE.k) / (COUNTS.n + THE.k * hs)
    like = math.log(like)
    for col, values in rule:
      f = sum(COUNTS.f.get((h, col, v), 0) for v in values)
      inc = (f + THE.m * prior) / (COUNTS.h[h] + THE.m)
      like += math.log(inc)
    return math.e**like

  def combine(rule1, rule2, here, there):
    val1, rule1 = rule1
    val2, rule2 = rule2
    tmp = dict()
    for rule in [rule1, rule2]:
      for k, lst in rule:
        tmp[k] = tmp.get(k, set())
        for v in lst:
          tmp[k].add(v)
    rule3 = sorted([[k, sorted(list(vs))] for k, vs in tmp.items()])
    val3 = value(rule3, here, there)
    return [val3, rule3]

  def same(rule1, rule2):
    if rule1[0] != rule2[0]:
      return False
    for x, y in zip(rule1[1], rule2[1]):
      if x != y:
        return False
    return True

  def prune(old):
    ordered = [[s, r] for s, r in sorted(old, reverse=True)]
    one = ordered[0]
    unique = [one]
    for two in ordered[1:]:
      if not same(one, two):
        unique += [two]
      one = two
    pruned = [[s, r] for s, r in unique if s &gt; 0][:THE.beam]
    return sum(s for s, _ in pruned), pruned

  def pick(rules, total):  # (s1, r1) (s2,r2) (s3,r3) total=s1+s2+s3
    n = r()
    for rule in rules:
      n -= rule[0] / total
      if n &lt;= 0:
        return rule
    return rule

  def rule0(c, x, here, there):
    rule = [[c, [x]]]
    return [value(rule, here, there), rule]

  out, all = {}, list(set([(c, x) for (_, c, x) in COUNTS.f]))
  for there in COUNTS.h:
    for here in COUNTS.h:
      if here != there:
        rules = loop([rule0(c, x, here, there)
                      for c, x in all], here, there)
        out[here] = [[value(r, here, there, 1), r] for _, r in rules]
  return out

def main():
  return discretize(
      classify(
          table(
              csv(THE.path2data + &#34;/&#34; + THE.data))))

#####################################################
def _main():
  seed(THE.seed)
  t = main()
  for k, rules in learn(counts(t)).items():
    print(&#34;&#34;)
    print(k, &#34;if&#34;)
    print(&#34;    N  &#34; + &#39; &#39;.join([f&#34;  {col.txt:5}&#34;
                                for col in t.y.values()]))
    for rule in rules:
      ys = {}
      some = selects(t, rule)
      for row in some:
        for col in t.y.values():
          ys[col.txt] = ys.get(col.txt, []) + [row.cells[col.pos]]
      print(
          f&#34;{len(some):5}  &#34; + &#39; &#39;.join([f&#34;{mu(ys[k]):7.2f}&#34;
                                         for k in ys]), end=&#34;   &#34;)
      print(showRule(rule))


#######################################################
if __name__ == &#34;__main__&#34;:
  THE = args(&#34;duo4&#34;, __doc__.split(&#34;\n\n&#34;)[0], THE)
  _main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="duo.classify"><code class="name flex">
<span>def <span class="ident">classify</span></span>(<span>tbl)</span>
</code></dt>
<dd>
<div class="desc"><p>Count how often each row dominates some others.
Classify a row as True if it scores in the top <em>best</em> range.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def classify(tbl):
  &#34;&#34;&#34;Count how often each row dominates some others.
     Classify a row as True if it scores in the top _best_ range.&#34;&#34;&#34;
  def norm(lst, x): return (
      x - lst[0]) / (lst[-1] - lst[0] + 1E-32)

  def better(tbl, row1, row2):
    &#34;Zitler&#39;s continous domination predicate (from IBEA, 2005).&#34;
    s1, s2, n = 0, 0, len(tbl.y)
    for col in tbl.y.values():
      pos, w = col.pos, col.w
      a, b = row1.cells[pos], row2.cells[pos]
      a, b = norm(col.has, a), norm(col.has, b)
      s1 -= math.e**(w * (a - b) / n)
      s2 -= math.e**(w * (b - a) / n)
    return s1 / n &lt; s2 / n
  #######################
  for row1 in tbl.rows:
    row1.score = sum(better(tbl, row1, any(tbl.rows))
                     for _ in range(THE.rowsamples)) / THE.rowsamples
  for n, row in enumerate(sorted(tbl.rows, key=lambda z: z.score)):
    row.klass = n &gt; len(tbl.rows) * THE.best
  return tbl</code></pre>
</details>
</dd>
<dt id="duo.counts"><code class="name flex">
<span>def <span class="ident">counts</span></span>(<span>TBL)</span>
</code></dt>
<dd>
<div class="desc"><p>Counts (class column attribute) inside <code>TBL</code>
(where attributes are the discretized attributes).
THe counts take the form: (cKass,attribute,range,col), count.
For example, with best=.9, the counts from ../data/auto93.csv
are as follows. Note the simplicity of the decision space:
all that matters is displacement and horsepower is above below
141 and 74</p>
<p>(False, 'displacement', 141, 1) 154
(False, 'displacement', inf, 1) 205
(False, 'horsepower', 74, 2) 48
(False, 'horsepower', inf, 2) 307
....
(True, 'displacement', 141, 1) 38
(True, 'displacement', inf, 1) 1
(True, 'horsepower', 74, 2) 34
(True, 'horsepower', inf, 2) 3
....</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def counts(TBL):
  &#34;&#34;&#34;Counts (class column attribute) inside `TBL`
   (where attributes are the discretized attributes).
   THe counts take the form: (cKass,attribute,range,col), count.
   For example, with best=.9, the counts from ../data/auto93.csv
   are as follows. Note the simplicity of the decision space:
   all that matters is displacement and horsepower is above below
   141 and 74

      (False, &#39;displacement&#39;, 141, 1) 154
      (False, &#39;displacement&#39;, inf, 1) 205
      (False, &#39;horsepower&#39;, 74, 2) 48
      (False, &#39;horsepower&#39;, inf, 2) 307
      ....
      (True, &#39;displacement&#39;, 141, 1) 38
      (True, &#39;displacement&#39;, inf, 1) 1
      (True, &#39;horsepower&#39;, 74, 2) 34
      (True, &#39;horsepower&#39;, inf, 2) 3
      ....

   &#34;&#34;&#34;

  def Counts(): return o(f={}, h={}, n=0)
  out = Counts()
  for row in TBL.rows:
    k = row.klass
    out.n += 1
    out.h[k] = out.h.get(k, 0) + 1
    for col in TBL.x.values():
      x = cell(col, row)
      if x:
        v = (k, col.txt, x)
        out.f[v] = out.f.get(v, 0) + 1
  return out</code></pre>
</details>
</dd>
<dt id="duo.discretize"><code class="name flex">
<span>def <span class="ident">discretize</span></span>(<span>TBL)</span>
</code></dt>
<dd>
<div class="desc"><p>Reports <code>bins</code> for each numeric columns. Initially,
columns of <code>N</code> (x,y) values
into bins of size N^Xchop.
Combines bins that are smaller than <code>sd(x)*xsmall</code>. Then combine
bins that are different by less than <code>sd(y)*ysmall</code>. Also, if
two adjacent bins are not not 'best', then they are dull and
we fuse them.
For example, from ../data/auto93.csv, we
get
learn that '-cylinders' effectively divides into 3:</p>
<p>[{'hi': 4, 'lo': -inf},
{'hi': 8, 'lo': 5},
{'hi': inf, 'lo': 5}]</p>
<p>Note that the above used 'best=.5' i.e. we were were dividing data
half:half into best:rest. But we ran the same code with 'best=.8' then
we find a different picture of what is interesting or not:</p>
<p>[{'hi': 4, 'lo': -inf},
{'hi': inf, 'lo': 3}]</p>
<p>That is, at 'best=.8' all we care about is whether or not 'cylinders'
is above or below 3.;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def discretize(TBL):
  &#34;&#34;&#34;Reports `bins` for each numeric columns. Initially,
  columns of `N` (x,y) values  into bins of size N^Xchop.
  Combines bins that are smaller than `sd(x)*xsmall`. Then combine
  bins that are different by less than `sd(y)*ysmall`. Also, if
  two adjacent bins are not not &#39;best&#39;, then they are dull and
  we fuse them.  For example, from ../data/auto93.csv, we
  get  learn that &#39;-cylinders&#39; effectively divides into 3:

    [{&#39;hi&#39;: 4, &#39;lo&#39;: -inf},
     {&#39;hi&#39;: 8, &#39;lo&#39;: 5},
     {&#39;hi&#39;: inf, &#39;lo&#39;: 5}]

  Note that the above used &#39;best=.5&#39; i.e. we were were dividing data
  half:half into best:rest. But we ran the same code with &#39;best=.8&#39; then
  we find a different picture of what is interesting or not:

    [{&#39;hi&#39;: 4, &#39;lo&#39;: -inf},
     {&#39;hi&#39;: inf, &#39;lo&#39;: 3}]

  That is, at &#39;best=.8&#39; all we care about is whether or not &#39;cylinders&#39;
  is above or below 3.;

  &#34;&#34;&#34;

  def Span(lo=-math.inf, hi=math.inf, has=None):
    return o(lo=lo, hi=hi, _has=has if has else [])

  def pairs(lst, fx, fy):
    xs, ys, xy = [], [], []
    for one in lst:
      x = fx(one)
      if x != &#34;?&#34;:
        y = fy(one)
        xs += [x]
        ys += [y]
        xy += [(x, y)]
    ys = sorted(ys)
    return (sd(sorted(xs)) * THE.xsmall,
            sd(ys) * THE.ysmall,
            ys[int(THE.best * len(ys))],
            sorted(xy))

  def div(xsmall, ysmall, ymin, xy):
    n = len(xy)**THE.Xchop
    while n &lt; 4 and n &lt; len(xy) / 2:
      n *= 1.2
    n, tmp, b4, span = int(n), [], 0, Span(lo=xy[0][0])
    now = n
    while now &lt; len(xy) - n:
      x = xy[now][0]
      span.hi = x
      now += 1
      if (now - b4 &gt; n and now &lt; len(xy) - 2
          and x != xy[now][0]
              and span.hi - span.lo &gt; xsmall):
        span._has = [z[1] for z in xy[b4:now]]
        tmp += [span]
        span = Span(lo=xy[now][0])
        b4 = now
        now += n
    tmp += [Span(lo=xy[b4][0], hi=xy[-1][0],
                 has=[z[1] for z in xy[b4:]])]
    out = merge(tmp, ymin, ysmall)
    out[0].lo = -math.inf
    out[-1].hi = math.inf
    return out

  def merge(b4, ymin, ysmall):
    j, now = 0, []
    while j &lt; len(b4):
      a = b4[j]
      if j &lt; len(b4) - 1:
        b = b4[j + 1]
        if (abs(mu(b._has) - mu(a._has)) &lt; ysmall
            or
                (mu(b._has) &lt; ymin and mu(a._has) &lt; ymin)):
          merged = Span(lo=a.lo, hi=b.hi, has=a._has + b._has)
          now += [merged]
          j += 2
      now += [a]
      j += 1
    return merge(now, ymin, ysmall) if len(now) &lt; len(b4) else now

  for col in TBL.x.values():
    if numsp(col.has):
      col.spans = div(*pairs(TBL.rows,
                             lambda z: z.cells[col.pos],
                             lambda z: z.score))
      print(f&#34;NUM {col.txt:12} :&#34;, [x.hi for x in col.spans])
    else:
      print(f&#34;SYM {col.txt:12} :&#34;, sorted(col.has.keys()))
  return TBL</code></pre>
</details>
</dd>
<dt id="duo.learn"><code class="name flex">
<span>def <span class="ident">learn</span></span>(<span>COUNTS)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def learn(COUNTS):
  def loop(rules, here, there):
    lives = THE.lives
    while True:
      lives -= 1
      total, rules = prune(rules)
      if lives &lt; 1 or len(rules) &lt; 2:
        return rules
      rules += [combine(pick(rules, total),
                        pick(rules, total),
                        here, there)]

  def value(rule, here, there, e=2):
    b = like(rule, here, 2)
    r = like(rule, there, 2)
    return b**e / (b + r) if b &gt; r else 0

  def like(rule, h, hs=None):
    hs = hs if hs else len(COUNTS.h)
    like = prior = (COUNTS.h[h] + THE.k) / (COUNTS.n + THE.k * hs)
    like = math.log(like)
    for col, values in rule:
      f = sum(COUNTS.f.get((h, col, v), 0) for v in values)
      inc = (f + THE.m * prior) / (COUNTS.h[h] + THE.m)
      like += math.log(inc)
    return math.e**like

  def combine(rule1, rule2, here, there):
    val1, rule1 = rule1
    val2, rule2 = rule2
    tmp = dict()
    for rule in [rule1, rule2]:
      for k, lst in rule:
        tmp[k] = tmp.get(k, set())
        for v in lst:
          tmp[k].add(v)
    rule3 = sorted([[k, sorted(list(vs))] for k, vs in tmp.items()])
    val3 = value(rule3, here, there)
    return [val3, rule3]

  def same(rule1, rule2):
    if rule1[0] != rule2[0]:
      return False
    for x, y in zip(rule1[1], rule2[1]):
      if x != y:
        return False
    return True

  def prune(old):
    ordered = [[s, r] for s, r in sorted(old, reverse=True)]
    one = ordered[0]
    unique = [one]
    for two in ordered[1:]:
      if not same(one, two):
        unique += [two]
      one = two
    pruned = [[s, r] for s, r in unique if s &gt; 0][:THE.beam]
    return sum(s for s, _ in pruned), pruned

  def pick(rules, total):  # (s1, r1) (s2,r2) (s3,r3) total=s1+s2+s3
    n = r()
    for rule in rules:
      n -= rule[0] / total
      if n &lt;= 0:
        return rule
    return rule

  def rule0(c, x, here, there):
    rule = [[c, [x]]]
    return [value(rule, here, there), rule]

  out, all = {}, list(set([(c, x) for (_, c, x) in COUNTS.f]))
  for there in COUNTS.h:
    for here in COUNTS.h:
      if here != there:
        rules = loop([rule0(c, x, here, there)
                      for c, x in all], here, there)
        out[here] = [[value(r, here, there, 1), r] for _, r in rules]
  return out</code></pre>
</details>
</dd>
<dt id="duo.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main():
  return discretize(
      classify(
          table(
              csv(THE.path2data + &#34;/&#34; + THE.data))))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<center>
<a href="http://menzies.us/duo"><img src="letscook.png" width=500></a>
<p><a href="#license">&copy; 2021</a>, Tim Menzies<br>
<a href="mailto:timm@ieee.org">timm@ieee.org</a><br>
<a href="http://menzies.us">http://menzies.us</a>
</p>
<p>
"Give me the fruitful error any time,
full of seeds, bursting with its own
corrections. You can keep your sterile
truth for yourself."
-&nbsp;Vilfredo&nbsp;Pareto</p>
<p>
<br><img src="https://img.shields.io/badge/language-python3,bash-blue">
<br><img src="https://img.shields.io/badge/purpose-ai%20,%20se-blueviolet">
<br><img src="https://img.shields.io/badge/license-mit-lightgrey"></p><hr>
<p>
<a href="https://github.com/timm/duo/blob/master/README.md"><img src="github.png" width=40></a>
<a href="https://github.com/timm/duo/archive/master.zip"> <img src="zip.png" width=40></a>
</p>
</center>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="duo.classify" href="#duo.classify">classify</a></code></li>
<li><code><a title="duo.counts" href="#duo.counts">counts</a></code></li>
<li><code><a title="duo.discretize" href="#duo.discretize">discretize</a></code></li>
<li><code><a title="duo.learn" href="#duo.learn">learn</a></code></li>
<li><code><a title="duo.main" href="#duo.main">main</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>